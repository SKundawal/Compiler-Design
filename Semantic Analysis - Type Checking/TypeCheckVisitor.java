//
// Generated by JTB 1.3.2
//

import visitor.*;
import syntaxtree.*;

import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class TypeCheckVisitor extends GJDepthFirst<String,Map<String,String>> {
   //
   // User-generated visitor methods below
   //

   SymbolTable symTbl = new SymbolTable();
   Helper helper = new Helper();
   Traitor traitor = new Traitor();
   String curClass;
   String curMethod;
   boolean constructPartialSymbolTable;
   List<String> argsList;
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public String visit(Goal n, Map<String,String> argu) {
      n.f0.accept(this, null);
      constructPartialSymbolTable = true;
      n.f1.accept(this, null);
      constructPartialSymbolTable = false;
      n.f1.accept(this, null);
      n.f2.accept(this, null);
      System.out.println("Assignment: " + traitor.assignmentErrors);
      System.out.println("Binop: " + traitor.binaryOperationErrors);
      System.out.println("Control: " + traitor.controlErrors);
      System.out.println("Function: " + traitor.functionErrors);
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public String visit(MainClass n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String className = n.f1.accept(this, null);
      curClass = className;
      curMethod = "main";
      symTbl.classDeclaration(curClass, null);
      symTbl.methodDeclaration(curClass, curMethod, "void");
      n.f2.accept(this, null);
      n.f3.accept(this, null);
      n.f4.accept(this, null);
      n.f5.accept(this, null);
      n.f6.accept(this, null);
      n.f7.accept(this, null);
      n.f8.accept(this, null);
      n.f9.accept(this, null);
      n.f10.accept(this, null);
      String arg = n.f11.accept(this, null);
      symTbl.table.get(curClass).methods.get(curMethod).args.add(arg);
      symTbl.table.get(curClass).methods.get(curMethod).vars.put(arg, "String[]");
      n.f12.accept(this, null);
      n.f13.accept(this, null);
      n.f14.accept(this, null);
      n.f15.accept(this, null);
      n.f16.accept(this, null);
      curClass = null;
      curMethod = null;
      return null;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n, Map<String,String> argu) {
      n.f0.accept(this, null);
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( MethodDeclaration() )*
    * f4 -> "}"
    */
   public String visit(ClassDeclaration n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String className = n.f1.accept(this, null);
      curClass = className;
      n.f2.accept(this, null);
      if(constructPartialSymbolTable){
         symTbl.classDeclaration(className, null);
      }
      for(Node methodList : n.f3.nodes){
         methodList.accept(this, null);
      }
      n.f4.accept(this, null);
      curClass = null;
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( MethodDeclaration() )*
    * f6 -> "}"
    */
   public String visit(ClassExtendsDeclaration n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String className = n.f1.accept(this, null);
      n.f2.accept(this, null);
      String parentClass = n.f3.accept(this, null);
      n.f4.accept(this, null);
      curClass = className;
      if(constructPartialSymbolTable){
         symTbl.classDeclaration(className, parentClass);
      }
      for(Node methodList : n.f5.nodes){
         methodList.accept(this, null);
      }
      n.f6.accept(this, null);
      curClass = null;
      return null;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n, Map<String,String> argu) {
      if(!constructPartialSymbolTable){
         String varType = n.f0.accept(this, null);
         String varName = n.f1.accept(this, null);
         if(symTbl.table.get(curClass).methods.get(curMethod).vars.containsKey(varName)){
            System.out.println("Multiple Declaration of variable " + varName + " in local variable of " + curMethod);
         } else {
            symTbl.table.get(curClass).methods.get(curMethod).vars.put(varName, varType);
         }
      }
      n.f2.accept(this, null);
      return null;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String methodType = n.f1.accept(this, null);
      String methodName = n.f2.accept(this, null);
      curMethod = methodName;
      if(constructPartialSymbolTable){
         symTbl.methodDeclaration(curClass, methodName, methodType);
      } else {
         n.f3.accept(this, null);
         System.out.println("Method Name: " + curMethod);
         /* FORMAL PARAMETERS */
         n.f4.accept(this, null);
         n.f5.accept(this, null);
         n.f6.accept(this, null);
         /* LOCAL VARIABLES */
         for(Node varList : n.f7.nodes){
            varList.accept(this, null);
         }
         /* Statement List */
         for(Node statement : n.f8.nodes){
            statement.accept(this, null);
         }
         n.f9.accept(this, null);
         String methodReturn = n.f10.accept(this, null);
         String methodReturnType = symTbl.getType(curClass, curMethod, methodReturn);

         if(!methodReturnType.equals(methodType)){
            if(!symTbl.isExtendable(methodType, methodReturnType)){
               traitor.incrementFunctionErrorCounter();
               System.out.println("Return type of " + curMethod + " isn't compatible.");
            }
         }
      }
      n.f11.accept(this, null);
      n.f12.accept(this, null);
      curMethod = null;
      return null;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      return null;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n, Map<String,String> argu) {
      String formalParameterType = n.f0.accept(this, null);
      String formalParameterName = n.f1.accept(this, null);
      if(symTbl.table.get(curClass).methods.get(curMethod).vars.containsKey(formalParameterName)){
         System.out.println("Multiple Declaration of variable " + formalParameterName + " in formal parameters of " + curMethod);
      } else {
         symTbl.table.get(curClass).methods.get(curMethod).args.add(formalParameterName);
         symTbl.table.get(curClass).methods.get(curMethod).vars.put(formalParameterName, formalParameterType);
      }
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      return null;
   }

   /**
    * f0 -> BooleanType()
    *       | IntegerType()
    *       | FloatType()
    *       | Identifier()
    */
   public String visit(Type n, Map<String,String> argu) {
      return n.f0.accept(this, null);
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "float"
    */
   public String visit(FloatType n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public String visit(Statement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      return null;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      n.f2.accept(this, null);
      return null;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */

   public String visit(AssignmentStatement n, Map<String,String> argu) {
      String left = n.f0.accept(this, null);
      String leftType = symTbl.getType(curClass, curMethod, left);
      n.f1.accept(this, null);
      String right = n.f2.accept(this, null);
      String rightType = symTbl.getType(curClass, curMethod, right);
      if(leftType == null || rightType == null){
         traitor.incrementAssignmentErrorCounter();
         System.out.println(left + " variable Not Declared!");
      } else if(leftType.equals("float") && rightType.equals("int")){
         rightType = "float";
      } else if(symTbl.isClass(leftType) && symTbl.isClass(rightType)){
         if(!symTbl.isExtendable(leftType, rightType)){
            traitor.incrementAssignmentErrorCounter();
         }
      } else if(!symTbl.sameTypes(leftType, rightType)){
         traitor.incrementAssignmentErrorCounter();
         System.out.println("Assignment Error : " + left + " -> " + leftType + " doesn't match " + rightType);
      }
      n.f3.accept(this, null);
      return null;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public String visit(IfStatement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      return null;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(IfthenStatement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      String expr = n.f2.accept(this, null);
      String exprType = symTbl.getType(curClass, curMethod, expr);
      if(exprType == null || !exprType.equals("boolean")){
         traitor.incrementControlErrorCounter();
         System.out.println("Control: The expression is of type " + expr + " which doesn't match boolean type.");
      }
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return null;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfthenElseStatement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      String expr = n.f2.accept(this, null);
      String exprType = symTbl.getType(curClass, curMethod, expr);
      if(exprType == null || !exprType.equals("boolean")){
         traitor.incrementControlErrorCounter();
         System.out.println("Control: The expression is of type " + expr + " which doesn't match boolean type.");
      }
      n.f3.accept(this, null);
      n.f4.accept(this, null);
      n.f5.accept(this, null);
      n.f6.accept(this, null);
      return null;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      String expr = n.f2.accept(this, null);
      String exprType = symTbl.getType(curClass, curMethod, expr);
      if(exprType == null || !exprType.equals("boolean")){
         traitor.incrementControlErrorCounter();
         System.out.println("Control: The expression is of type " + expr + " which doesn't match boolean type.");
      }
      n.f3.accept(this, null);
      n.f4.accept(this, null);
      return null;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      n.f2.accept(this, null);
      n.f3.accept(this, null);
      n.f4.accept(this, null);
      return null;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public String visit(Expression n, Map<String,String> argu) {
      return n.f0.accept(this, null);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&&"
    * f2 -> PrimaryExpression()
    */
   public String visit(AndExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, null);
      n.f1.accept(this, null);
      String rightExpr = n.f2.accept(this, null);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);

      String finalType = "boolean";
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }
      if((leftExprType != null && !leftExprType.equals("boolean")) || (rightExprType != null && !rightExprType.equals("boolean"))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " is not of type boolean.");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "||"
    * f2 -> PrimaryExpression()
    */
   public String visit(OrExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, null);
      n.f1.accept(this, null);
      String rightExpr = n.f2.accept(this, null);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = "boolean";
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }
      if((leftExprType != null && !leftExprType.equals("boolean")) || (rightExprType != null && !rightExprType.equals("boolean"))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " is not of type boolean.");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<="
    * f2 -> PrimaryExpression()
    */
   public String visit(CompareExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, null);
      n.f1.accept(this, null);
      String rightExpr = n.f2.accept(this, null);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = "boolean";
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }
      if((leftExprType != null && !helper.isIntOrFloat(leftExprType)) || (rightExprType != null && !helper.isIntOrFloat(rightExprType))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " is not of type int.");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "!="
    * f2 -> PrimaryExpression()
    */
   public String visit(neqExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, null);
      n.f1.accept(this, null);
      String rightExpr = n.f2.accept(this, null);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = "boolean";
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibaleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }

      if((leftExprType != null && rightExprType != null && helper.isIntOrFloat(leftExprType) && !helper.isIntOrFloat(rightExprType)) || (leftExprType != null && rightExprType != null && !helper.isIntOrFloat(leftExprType) && helper.isIntOrFloat(rightExprType))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
      } else if(leftExprType != null && rightExprType != null && ((helper.isIntOrFloat(leftExprType) && !helper.isIntOrFloat(rightExprType))) || ((!helper.isIntOrFloat(leftExprType) && helper.isIntOrFloat(rightExprType)))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExprType + " isn't comparable with " + rightExprType);
      } else if(leftExprType != null && rightExprType != null && (!symTbl.isClass(leftExprType) || !symTbl.isClass(rightExprType))){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
      } else if(leftExprType != null && rightExprType != null && symTbl.isClass(leftExprType) && symTbl.isClass(rightExprType)){
         String leftExprFinalClass = symTbl.getFinalParentClass(leftExprType);
         String rightExprFinalClass = symTbl.getFinalParentClass(rightExprType);
         if(!leftExprFinalClass.equals(rightExprFinalClass)){
            finalType = "incompatibleType";
            traitor.incrementBinaryOerationErrorCounter();
         }
         System.out.println(leftExprType + " isn't comparable with " + rightExprType);
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public String visit(PlusExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, null);
      n.f1.accept(this, null);
      String rightExpr = n.f2.accept(this, null);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = ((leftExprType != null && leftExprType.equals("float")) || (rightExprType != null && rightExprType.equals("float")) ? "float" : "int");
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }
      if ((leftExprType != null && !helper.isIntOrFloat(leftExprType)) || (rightExprType != null && !helper.isIntOrFloat(rightExprType))) {
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println("Binop: " + leftExpr + " isn't of compatible type with + operator");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public String visit(MinusExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String rightExpr = n.f2.accept(this, argu);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = ((leftExprType != null && leftExprType.equals("float")) || (rightExprType != null && rightExprType.equals("float")) ? "float" : "int");

      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }

      if ((leftExprType != null && !helper.isIntOrFloat(leftExprType)) || (rightExprType != null && !helper.isIntOrFloat(rightExprType))) {
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " isn't of compatible type with - operator");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public String visit(TimesExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String rightExpr = n.f2.accept(this, argu);
      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);

      String finalType = ((leftExprType != null && leftExprType.equals("float")) || (rightExprType != null && rightExprType.equals("float")) ? "float" : "int");
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }

      if ((leftExprType != null && !helper.isIntOrFloat(leftExprType)) || (rightExprType != null && !helper.isIntOrFloat(rightExprType))) {
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " isn't of compatible type with * operator");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "/"
    * f2 -> PrimaryExpression()
    */
   public String visit(DivExpression n, Map<String,String> argu) {
      String leftExpr = n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      String rightExpr = n.f2.accept(this, argu);

      String leftExprType = symTbl.getType(curClass, curMethod, leftExpr);
      String rightExprType = symTbl.getType(curClass, curMethod, rightExpr);
      String finalType = ((leftExprType != null && leftExprType.equals("float")) || (rightExprType != null && rightExprType.equals("float")) ? "float" : "int");
      if(leftExprType == null || rightExprType == null){
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " has not been declared.");
      }

      if ((leftExprType != null && !helper.isIntOrFloat(leftExprType)) || (rightExprType != null && !helper.isIntOrFloat(rightExprType))) {
         finalType = "incompatibleType";
         traitor.incrementBinaryOerationErrorCounter();
         System.out.println(leftExpr + " isn't of compatible type with / operator");
      }
      return finalType;
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n, Map<String,String> argu) {
      String expr = n.f0.accept(this, null);
      String className = symTbl.getType(curClass, curMethod, expr);
      n.f1.accept(this, null);
      String methodName = n.f2.accept(this, null);
      if(className == null || !symTbl.table.containsKey(className)){
         System.out.println("Class " + className + " has not been declared.!");
      }

      String methodType = null;
      List<String> methodArgsList = new ArrayList<>();

      String parentClassName = symTbl.getDeclarationClassOfMethod(className, methodName);
      if(!symTbl.classMethod(className, methodName) && parentClassName != null){
         className = parentClassName;
         methodType = symTbl.table.get(parentClassName).methods.get(methodName).methodType;
         methodArgsList = symTbl.table.get(parentClassName).methods.get(methodName).args;
      } else if(className != null && symTbl.classMethod(className, methodName)){
         methodType = symTbl.table.get(className).methods.get(methodName).methodType;
         methodArgsList = symTbl.table.get(className).methods.get(methodName).args;
      } else {
         System.out.println("Method " + methodName + " not declared.!");
      }

      n.f3.accept(this, null);
      argsList = new ArrayList<>();
      n.f4.accept(this, null);

      if(argsList.size() != 0){
         if(methodArgsList.size() != argsList.size()){
            traitor.incrementFunctionErrorCounter();
            System.out.println("Number of arguments in " + methodName + " signature are different.");
         }
      }

      int iterator = 0;
      if(argsList.size() != 0){
         for(String arg : methodArgsList){
            if(iterator < argsList.size()){
               String argType = symTbl.getType(curClass, curMethod, argsList.get(iterator++));
               String methodArg = symTbl.getType(className, methodName, arg);
               if(!symTbl.sameTypes(methodArg, argType)){
                  traitor.incrementFunctionErrorCounter();
                  System.out.println(methodName + ": argument Types of the callee and called methods are of different types.");
               }
            }
         }
      }
      argsList.clear();
      n.f5.accept(this, null);
      return methodType;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public String visit(ExpressionList n, Map<String,String> argu) {
      argsList.add(n.f0.accept(this, null));
      for(Node exprRest : n.f1.nodes){
         exprRest.accept(this, null);
      }
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public String visit(ExpressionRest n, Map<String, String> argu) {
      n.f0.accept(this, null);
      argsList.add(n.f1.accept(this, null));
      return null;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | FloatLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public String visit(PrimaryExpression n, Map<String,String> argu) {
      String id = n.f0.accept(this, null);
      if(id == null){
         System.out.println(id + " has not been declared.!");
      }
      return id;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> <FLOAT_LITERAL>
    */
   public String visit(FloatLiteral n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n, Map<String,String> argu) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n, Map<String,String> argu) {
      return curClass;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String className = n.f1.accept(this, null);
      if(!symTbl.table.containsKey(className)){
         className = "incompatibleType";
         System.out.println("Class " + className + " has not been declared.!");
      }
      n.f2.accept(this, null);
      n.f3.accept(this, null);
      return className;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public String visit(NotExpression n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String expr = n.f1.accept(this, null);
      String exprType = symTbl.getType(curClass, curMethod,  expr);
      if(expr == null || !exprType.equals("boolean")){
         exprType = "incompatibleType";
         System.out.println("Expr Type: " + exprType + ", ! is not followed by boolean type.!");
      }
      return exprType;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public String visit(BracketExpression n, Map<String,String> argu) {
      n.f0.accept(this, null);
      String _ret = n.f1.accept(this, null);
      n.f2.accept(this, null);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( IdentifierRest() )*
    */
   public String visit(IdentifierList n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public String visit(IdentifierRest n, Map<String,String> argu) {
      n.f0.accept(this, null);
      n.f1.accept(this, null);
      return null;
   }
}
