//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

import static visitor.Helper.fieldIndex;
import static visitor.Helper.uncheckedCast;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJNoArguDepthFirst<R> implements GJNoArguVisitor<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   int objectIndex;
   boolean firstPass = true;
   String currentClass;
   String currentMethod;
   SymbolTable symbolTable = new SymbolTable();
   Helper helper = new Helper();
   StringBuilder outputString;
   SecPassSymTbl secPassSymTbl = new SecPassSymTbl();
   Object object = new Object();


   class Object{
      LinkedHashMap<String, ObjectTable> ObjectTable;
      public Object(){
         this.ObjectTable = new LinkedHashMap<>();
      }
   }

   class ObjectTable{
      String className;
      LinkedHashMap<String, FieldInfo> fieldInfo;     // key -> variableName //SAME FIELD NAME ISSUE
      LinkedHashMap<String, vTable> vTable;     // key -> methodName

      public ObjectTable(String className){
         this.className = className;
         this.fieldInfo = new LinkedHashMap<>();
         this.vTable = new LinkedHashMap<>();
      }
   }

   static class FieldInfo{
      String fieldName;
      String linkedObjectName;
      int fieldIndex;
      int defaultValue;

      public FieldInfo(String fieldName, String linkedObjectName, int fieldIndex){
         this.fieldName = fieldName;
         this.linkedObjectName = linkedObjectName;
         this.fieldIndex = fieldIndex;
         this.defaultValue = 0;
      }
   }

   static class vTable{
      String methodName;
      String linkedObjectName;
      int methodIndex;

      public vTable(String methodName, String linkedObjectName, int methodIndex){
         this.methodName = methodName;
         this.linkedObjectName = linkedObjectName;
         this.methodIndex = methodIndex;
      }
   }
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n) {
      n.f0.accept(this);
      n.f1.accept(this);
      firstPass = false;
      outputString = new StringBuilder();
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      outputString.append("}");
      System.out.println(outputString);
      return null;
   }

   /**
    * f0 -> "package"
    * f1 -> Identifier()
    * f2 -> ";"
    * f3 -> "public class"
    * f4 -> Identifier()
    * f5 -> "{"
    * f6 -> "public"
    * f7 -> "static"
    * f8 -> "void"
    * f9 -> "main"
    * f10 -> "("
    * f11 -> "String"
    * f12 -> "["
    * f13 -> "]"
    * f14 -> Identifier()
    * f15 -> ")"
    * f16 -> "{"
    * f17 -> ( VarDeclaration() )*
    * f18 -> ( Statement() )*
    * f19 -> "}"
    * f20 -> "}"
    */

   public R visit(MainClass n) {
      currentClass = (String) n.f4.accept(this);
      String methodType = n.f8.tokenImage;
      currentMethod = n.f9.tokenImage;
      String argName = (String)n.f14.accept(this);
      if(firstPass){
         symbolTable.classDeclaration(currentClass, null);
         symbolTable.methodDeclaration(currentClass, currentMethod, methodType);
         symbolTable.table.get(currentClass).classMethods.get(currentMethod).args.add(argName);
         symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.put(argName, "String[]");
         /**
          * SecPassSymbTble
          */
         secPassSymTbl.classDeclaration(currentClass, null);
         secPassSymTbl.methodDeclaration(currentClass, currentMethod, currentClass + "_" + currentMethod);
         /**
          * Variable Declaration
          */
         for(Node vars : n.f17.nodes){
            vars.accept(this);
         }
         helper.resetVariableIndex();
         /**
          * Statement Declaration
          */
         for(Node statement : n.f18.nodes){
            statement.accept(this);
         }
      } else {
         String packageName = (String)n.f1.accept(this);
         outputString.append("package ").append(packageName).append(";\n\n");
         outputString.append("import static ").append(packageName).append(".memmgr.MemMgr.*;\n\n");
         outputString.append("public class Main {\n");

         outputString.append("public static void main(String[] ").append(argName).append(") {\n");

         /**
          * Variable Declaration Part Done Here
          */
         objectIndex = 1;
         StringBuilder varsExceptClass = new StringBuilder();
         for(Node vars : n.f17.nodes){
            varsExceptClass.append((StringBuilder)vars.accept(this));
         }
         if(needToCreateObjectForClass){
            outputString.append("Object vTablePtr;\n");
            outputString.append("String fnName;\n");
            needToCreateObjectForClass = false;
         }
         outputString.append(varsExceptClass);
         objectIndex = 1;

         /**
          * Allocation Part
          * Statement Declaration
          */
         StringBuilder statementSB = new StringBuilder();
         for(Node statement : n.f18.nodes){
            statementSB.append((StringBuilder)statement.accept(this));
         }
         outputString.append(statementSB);
         outputString.append("}\n");
      }
      currentClass = null;
      currentMethod = null;
      return null;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
      } else{
         outputString.append(n.f0.accept(this));
      }
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( FieldDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n) {
      R _ret = null;
      currentClass = (String)n.f1.accept(this);
      if(firstPass){
         symbolTable.classDeclaration(currentClass, null);
         /**
          * SecPassSymbolTable
          */
         secPassSymTbl.classDeclaration(currentClass, null);

         /**
          * Field Declaration
          */
         for(Node field : n.f3.nodes){
            field.accept(this);
         }

         /**
          * Method Declaration
          */
         for(Node method : n.f4.nodes){
            method.accept(this);
         }
      } else {
         StringBuilder classDeclarationSB = new StringBuilder();

         /**
          * Handled Field Declaration Part using Symbol Table
          */

         /**
          * Method Declaration
          */
         for(Node methodDeclaration : n.f4.nodes){
            classDeclarationSB.append((StringBuilder)methodDeclaration.accept(this));
            classDeclarationSB.append("}\n");
         }
         _ret = uncheckedCast(classDeclarationSB);
      }
      return (_ret == null ? (R)new StringBuilder() : _ret);
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( FieldDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n) {
      R _ret=null;
      currentClass = (String)n.f1.accept(this);
      String parentClass = (String)n.f3.accept(this);
      if(firstPass){
         symbolTable.classDeclaration(currentClass, parentClass);
         /**
          * SecPassSymbolTable
          */
         secPassSymTbl.classDeclaration(currentClass, parentClass);

         /**
          * Field Declaration
          */
         for(Node fieldDeclaration : n.f5.nodes){
            fieldDeclaration.accept(this);
         }

         /**
          * Method Declaration
          */
         for(Node methodDeclaration : n.f6.nodes){
            methodDeclaration.accept(this);
         }
      } else {
         StringBuilder classExtendsDeclarationSB = new StringBuilder();

         /**
          * Handled Field Declaration Part using Symbol Table
          */

         /**
          * Method Declaration
          */
         for(Node methodDeclaration : n.f6.nodes){
            classExtendsDeclarationSB.append((StringBuilder)methodDeclaration.accept(this));
            classExtendsDeclarationSB.append("}\n");
         }
         _ret = uncheckedCast(classExtendsDeclarationSB);
      }
      return (_ret == null ? (R)new StringBuilder() : _ret);
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   boolean needToCreateObjectForClass = false;
   public R visit(VarDeclaration n) {
      R _ret = null;
      String varType = (String)n.f0.accept(this);
      String varName = (String)n.f1.accept(this);
      if(firstPass){
         /**
         Constructing Symbol Table
         */
         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(varName)){
            symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.put(varName, varType);

            /**
             * SecPassSymbTbl
             */
            Mappings mappings = new Mappings(varType, (varType != "int" ? true : false), false);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.put(varName, mappings);
         } else {
            System.out.println("Multiple declaration of variable " + varName + " in method " + currentMethod + " of class " + currentClass);
         }
      } else {
         /**
          Second Pass Stuff
          */
         StringBuilder varsExceptClass = new StringBuilder();
         if(currentMethod == "main"){
            if(varType == "int" || varType == "boolean"){
               varsExceptClass.append(varType).append(" ").append(varName).append(";\n");
            } else {
               if (secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).isObjectCreated){
                  needToCreateObjectForClass = true;
                  //Changes done here
                  secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("o" + objectIndex);
                  outputString.append("Object o").append(objectIndex++).append(";\n");
                  secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("o" + objectIndex);
                  outputString.append("Object o").append(objectIndex++).append(";\n");
                  outputString.append("Object ").append(varName).append(";\n");
               } else{
                  /**
                   * No object created ---> no need to print the variables but need to do the vTablePtr & fname.
                   */
                  needToCreateObjectForClass = true;
               }
            }
            _ret = (R)varsExceptClass;
         } else {
            StringBuilder methodVarDeclaration = new StringBuilder();
            if(varType == "int" || varType == "boolean"){
               varLinkerRHS.put(varName, helper.getNewVariable());
               varsExceptClass.append(varType).append(" ").append(helper.getNewVariable()).append(";\n");
               helper.incrementVariableIndex();
            } else {
               if (secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).isObjectCreated){
                  needToCreateObjectForClass = true;
                  secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("x" + objectIndex);
                  methodVarDeclaration.append("Object x").append(objectIndex++).append(";\n");
                  secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("x" + objectIndex);
                  methodVarDeclaration.append("Object x").append(objectIndex++).append(";\n");
                  methodVarDeclaration.append("Object ").append(varName).append(";\n");
               } else{
                  /**
                   * No object created ---> no need to print the variables but need to do the vTablePtr & fname.
                   */
                  needToCreateObjectForClass = true;
               }
            }
            methodVarDeclaration.append(varsExceptClass);
            _ret = (R)methodVarDeclaration;
         }



//         StringBuilder varsExceptClass = new StringBuilder();
//         if(varType == "int"){
//            _ret = uncheckedCast(varsExceptClass.append(varType).append(" ").append(varName).append(";\n"));
//         } else {
//            if (secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).isObjectCreated){
//               needToCreateObjectForClass = true;
//               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("x" + objectIndex);
//               outputString.append("Object x").append(objectIndex++).append(";\n");
//               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(varName).linkedVariables.add("x" + objectIndex);
//               outputString.append("Object x").append(objectIndex++).append(";\n");
//               outputString.append("Object ").append(varName).append(";\n");
//            } else{
//               /**
//                * No object created ---> no need to print the variables but need to do the vTablePtr & fname.
//                */
//               outputString.append("Object vTablePtr;\n");
//               outputString.append("String fnName;\n");
//            }
//         }
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> IntegerType()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(FieldDeclaration n) {
      String classFieldName = (String)n.f1.accept(this);
      String classFieldType = (String)n.f0.accept(this);
      if(firstPass){
         if(!symbolTable.table.get(currentClass).classFields.containsKey(classFieldName)){
            symbolTable.table.get(currentClass).classFields.put(classFieldName, classFieldType);

            /**
             * SecPassTableInfo
             *
             * CHECK AS PER LOGIC, SEEMS FISHY
             */
            SecPassClassFieldInfo secPassClassFieldInfo = new SecPassClassFieldInfo(classFieldType, helper.getNewVariable());
            secPassSymTbl.table.get(currentClass).classMapping.put(classFieldName, secPassClassFieldInfo);
         } else {
            System.out.println("Multiple field declaration of " + classFieldName + " in class " + currentClass);
         }
      } else {
         /**
          * Second Pass
          */
      }
      return null;
   }

   /**
    * f0 -> "public"
    * f1 -> IntegerType()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> SubPrimaryExpression()
    * f11 -> ";"
    * f12 -> "}"
    */
   HashMap<String, String> varLinkerRHS = new HashMap<>();
   HashMap<String, String> varLinkerLHS = new HashMap<>();
   public R visit(MethodDeclaration n) {
      R _ret=null;
      String methodType = (String)n.f1.accept(this);
      String methodName = (String)n.f2.accept(this);
      currentMethod = methodName;
      if(firstPass){
         symbolTable.methodDeclaration(currentClass, methodName, methodType);

         /**
          * SecPassSymbolTable Stuff
          */
         secPassSymTbl.methodDeclaration(currentClass, currentMethod, currentClass + "_" + currentMethod);

         /**
          * Formal Parameter List
          */
         n.f4.accept(this);

         /**
          * Variable Declaration
          */
         for(Node variable : n.f7.nodes){
            variable.accept(this);
         }

         /**
          * Statement Declaration
          */
         for(Node statement : n.f8.nodes){
            statement.accept(this);
         }
      } else {
         StringBuilder methodDeclarationSB = new StringBuilder();
         methodDeclarationSB.append("public static ").append(methodType).append(" ").append(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).mappedMethodName).append("(Object mthis").append(n.f4.accept(this) == null ? "" : n.f4.accept(this)).append(") {\n");
         /**
          * Variable Declaration
          * Cases to take care
          * 1.If there's a class variable -> vtablePtr, fnName
          * 2.If there are field variable used on RHS, add a temp variable for that
          */
         StringBuilder varDeclarationSB = new StringBuilder();

         /**
          * to handle load cases if any class field is present on RHS of an assignment expression
          */
         for (Map.Entry<String, String> fieldsUsedRHS : secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod .entrySet()) {
            varLinkerRHS.put(fieldsUsedRHS.getKey(), helper.getNewVariable());
            varDeclarationSB.append(secPassSymTbl.table.get(fieldsUsedRHS.getValue()).classMapping.get(fieldsUsedRHS.getKey()).fieldType).append(" ").append(varLinkerRHS.get(fieldsUsedRHS.getKey())).append(";\n");
            helper.incrementVariableIndex();
         }
         /**
          * to handle store cases if any class field is present on LHS of an assignment expression
          */
         for (Map.Entry<String, String> fieldsUsedLHS : secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod .entrySet()) {
            varLinkerLHS.put(fieldsUsedLHS.getKey(), helper.getNewVariable());
            varDeclarationSB.append(secPassSymTbl.table.get(fieldsUsedLHS.getValue()).classMapping.get(fieldsUsedLHS.getKey()).fieldType).append(" ").append(varLinkerLHS.get(fieldsUsedLHS.getKey())).append(";\n");
            helper.incrementVariableIndex();
         }


         /**
          * to handle local variables
          */
         for(Node varDeclaration : n.f7.nodes){
            varDeclarationSB.append((StringBuilder)varDeclaration.accept(this));
         }
         if(needToCreateObjectForClass){
            varDeclarationSB.append("Object vTablePtr;\n");
            varDeclarationSB.append("String fnName;\n");
            needToCreateObjectForClass = false;
         }
         objectIndex = 1;

//         for (Map.Entry<String, Mappings> methodVars : secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.entrySet()) {
//            if (methodVars.getValue().varType == "int") {
//               varLinkerRHS.put(methodVars.getKey(), helper.getNewVariable());
//               varDeclarationSB.append(methodVars.getValue().varType).append(" ").append(helper.getNewVariable()).append(";\n");
//               helper.incrementVariableIndex();
//            } else {
//               varDeclarationSB.append("Object vTablePtr;\n");
//               varDeclarationSB.append("String fnName;\n");
//            }
//         }
         methodDeclarationSB.append(varDeclarationSB);


         /**
          * Statement Declaration
          */
         for (Node statement : n.f8.nodes) {
            methodDeclarationSB.append(statement.accept(this));
         }

         /**
          * return statement
          */
         String returnSubExpression = (String)n.f10.accept(this);
         String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, returnSubExpression);
         if(!helper.isStringInt(returnSubExpression) && returnSubExpression != "true" && returnSubExpression != "false" && declarationClassOfField == null){
            returnSubExpression = varLinkerRHS.get(returnSubExpression);
         } else if(declarationClassOfField != null){
            methodDeclarationSB.append(symbolTable.table.get(declarationClassOfField).classFields.get(returnSubExpression) + " " + helper.getNewVariable() + ";\n");
            methodDeclarationSB.append(helper.getNewVariable() + " = (Integer) load(mthis, " + object.ObjectTable.get(declarationClassOfField).fieldInfo.get(returnSubExpression).fieldIndex + ");\n");
            returnSubExpression = helper.getNewVariable();
         }
         methodDeclarationSB.append("return " + returnSubExpression + ";\n");
         helper.resetVariableIndex();
         _ret = uncheckedCast(methodDeclarationSB);
      }
      varLinkerRHS.clear();
      varLinkerLHS.clear();
      currentMethod = null;
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
      } else{
         StringBuilder formalParameterListSB = new StringBuilder();
         formalParameterListSB.append((n.f0.accept(this) == null ? n.f0.accept(this) : ", " + n.f0.accept(this)));
         for(Node formalParameterRest : n.f1.nodes){
            formalParameterListSB.append(formalParameterRest.accept(this));
         }
         _ret = uncheckedCast(formalParameterListSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n) {
      R _ret=null;
      String formalParameterType = (String)n.f0.accept(this);
      String formalParameterName = (String)n.f1.accept(this);
      if(firstPass){
         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(formalParameterName)){
            symbolTable.table.get(currentClass).classMethods.get(currentMethod).args.add(formalParameterName);
            symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.put(formalParameterName, formalParameterType);
         } else {
            System.out.println("Multiple Declaration of variable " + formalParameterName + " in formal parameters of " + currentMethod);
         }
      } else {
         StringBuilder formalParameterSB = new StringBuilder();
         formalParameterSB.append(formalParameterType + " " + formalParameterName);
         _ret = uncheckedCast(formalParameterSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
      } else {
         StringBuilder formalParameterRestSB = new StringBuilder();
         formalParameterRestSB.append((n.f1.accept(this) == null ? "" : ", " + n.f1.accept(this)));
         _ret = uncheckedCast(formalParameterRestSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> BooleanType()
    *       | IntegerType()
    *       | StringType()
    *       | Identifier()
    *
    */
   public R visit(Type n) {
      R _ret= n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n) {
      R _ret= (R) n.f0.tokenImage ;
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n) {
      R _ret= (R) n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> "String"
    */
   public R visit(StringType n) {
      R _ret= (R) n.f0.tokenImage;
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | FieldAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n) {
      R _ret=null;
      if(firstPass){

         n.f0.accept(this);
      } else {
         StringBuilder statementSB = new StringBuilder();
         statementSB.append(n.f0.accept(this));
         _ret = uncheckedCast(statementSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
      } else {
         StringBuilder blockSB = new StringBuilder("{\n");
         for(Node statements : n.f1.nodes){
            blockSB.append(statements.accept(this));
         }
         blockSB.append("}\n");
         _ret = (R)blockSB;
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   String assignmentLHSVarName;
   String LHSObjectAllocation;
   boolean assignmentVariableShitON;
   public R visit(AssignmentStatement n) {
      R _ret = null;
      String LHS = (String)n.f0.accept(this);
      assignmentLHSVarName = LHS;

      if(firstPass){
         n.f1.accept(this);
         assignmentVariableShitON = true;
         n.f2.accept(this);
         assignmentVariableShitON = false;
         n.f3.accept(this);

      } else {
         /**
          * Check for class fields;
          * Cases to handle:
          * 1.Check if LHS belongs to method variables
          * 2.If case 1 fails, then it must belong to class field --> take care of inheritance too.
          *   and take care of store calls
          */
         if(currentMethod == "main"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.containsKey(LHS)){
               if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(LHS).isClassVariable){
                  LHSObjectAllocation = LHS;
               }
            }
         } else{
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.containsKey(LHS)){
               if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(LHS).isClassVariable){
                  LHSObjectAllocation = LHS;
               }
            }
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(LHS)){
               assignmentLHSVarName = LHS;
            } else if(varLinkerRHS.get(LHS) != null){
               assignmentLHSVarName = varLinkerRHS.get(LHS);
            }
         }
         /**
          * Handle x = a; like cases where x is a field reference & the expression doesn't go into Binary Operation.
          */
         assignmentVariableShitON = true;
         StringBuilder assignmentStatementSB = new StringBuilder();
         assignmentStatementSB.append(n.f2.accept(this));
         assignmentVariableShitON = false;
         _ret = (R)assignmentStatementSB;
      }
      assignmentLHSVarName = null;
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public R visit(FieldAssignmentStatement n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
         n.f3.accept(this);
         /**
          * If RHS has a class field, save it for load instruction generation
          */
         String RHS = (String)n.f4.accept(this);
         String declarationClassRHS = symbolTable.getDeclarationClassOfField(currentClass, RHS);
         if(declarationClassRHS != null && currentMethod != "main"){
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(RHS, declarationClassRHS);
         }
         n.f5.accept(this);
      } else {
         /**
          * Case to handle:
          * 1.RHS can be a field ---> in that case you have to load the value first and then assign
          *   it to the field on the LHS
          * 2. Store the LHS side field in object created for the class
          */
         String classNameObject = (String)n.f0.accept(this);
         String fieldName = (String)n.f2.accept(this);
         String RHS = (String)n.f4.accept(this);

         StringBuilder fieldAssignmentStatementSB = new StringBuilder();
         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(RHS)){
            String declarationClassOfRHS = symbolTable.getDeclarationClassOfField(currentClass, RHS);
            String declarationClassOfLHS = symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.get(classNameObject);
            int fieldIndexRHS = object.ObjectTable.get(declarationClassOfRHS).fieldInfo.get(RHS).fieldIndex;
            int fieldIndexLHS = object.ObjectTable.get(declarationClassOfLHS).fieldInfo.get(fieldName).fieldIndex;
            if(currentMethod == "main"){
               /**
                * TAKE CARE OF HOW TO LOAD IN MAIN CLASS
                */
               //fieldAssignmentStatementSB.append(varLinkerRHS.get(RHS)).append(" = ").append("(Integer) load(" + declarationClassOfRHS + ", ").append(fieldIndexRHS).append(");\n");
               fieldAssignmentStatementSB.append("store(").append(classNameObject).append(", ").append(fieldIndexLHS).append(", ").append(RHS).append(");\n");
            } else {
               fieldAssignmentStatementSB.append(varLinkerRHS.get(RHS)).append(" = ").append("(Integer) load(mthis, ").append(fieldIndexRHS).append(");\n");
               fieldAssignmentStatementSB.append("store(mthis, ").append(fieldIndexLHS).append(", ").append(varLinkerRHS.get(RHS)).append(");\n");
            }
         } else {
            String declarationClassOfLHS = symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.get(classNameObject);
;           int fieldIndexLHS = object.ObjectTable.get(declarationClassOfLHS).fieldInfo.get(fieldName).fieldIndex;
            if(currentMethod == "main"){
               fieldAssignmentStatementSB.append("store(").append(classNameObject).append(", ").append(fieldIndexLHS).append(", ").append(RHS).append(");\n");
            } else {
               fieldAssignmentStatementSB.append("store(mthis, ").append(fieldIndexLHS).append(", ").append(RHS).append(");\n");
            }
         }
         _ret = uncheckedCast(fieldAssignmentStatementSB);
      }
      return (_ret == null ? (R)new StringBuilder() : _ret);
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfStatement n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
         n.f3.accept(this);
         n.f4.accept(this);
         n.f5.accept(this);
         n.f6.accept(this);
      } else {
         /**
          * Handle load case
          */
         StringBuilder ifStatementSB = new StringBuilder();
         ifStatementSB.append("if(").append(varLinkerRHS.get(n.f2.accept(this))).append(")");
         ifStatementSB.append(n.f4.accept(this));
         ifStatementSB.append("else");
         ifStatementSB.append(n.f6.accept(this));
         _ret = (R)ifStatementSB;
      }

      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
         n.f3.accept(this);
         n.f4.accept(this);
      } else {
         StringBuilder whileSB = new StringBuilder("while(" + varLinkerRHS.get(n.f2.accept(this)) + ")");
         whileSB.append(n.f4.accept(this));
         _ret = (R)whileSB;
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> SubPrimaryExpression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
         n.f3.accept(this);
         n.f4.accept(this);
      } else {
         StringBuilder printStatementSB = new StringBuilder();
         /**
          * changes done here
          * varLinkerRHS.get(n.f2.accept(this))
          */
         printStatementSB.append("System.out.println(" + (varLinkerLHS.containsKey(n.f2.accept(this)) ? varLinkerLHS.get(n.f2.accept(this))
                 : varLinkerRHS.containsKey(n.f2.accept(this)) ? varLinkerRHS.get(n.f2.accept(this))
                 : symbolTable.getDeclarationClassOfField(currentClass, (String)n.f2.accept(this)) != null ? "(Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, (String)n.f2.accept(this))).fieldInfo.get(n.f2.accept(this)).fieldIndex + ")"
                 : n.f2.accept(this))
                 + ");\n");
         _ret = (R)printStatementSB;
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | NeqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | MessageSend()
    *       | FieldReference()
    *       | PrimaryExpression()
    */
   public R visit(Expression n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
      } else{
         StringBuilder expressionSB = new StringBuilder();
         expressionSB.append(n.f0.accept(this));
         _ret = uncheckedCast(expressionSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "&&"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(AndExpression n) {
      assignmentVariableShitON = false;
      R _ret=null;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }
         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder andExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               andExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               andExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            andExpressionSB.append(varLinkerLHS);
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            andExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            andExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerRHS.get(assignmentLHSVarName) + ");\n");
         } else {
            andExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(andExpressionSB);
      }

      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "||"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(OrExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder orExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               orExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               orExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            orExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            orExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerRHS.get(assignmentLHSVarName) + ");\n");
         } else {
            orExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(orExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "<"
    * f2 -> SubPrimaryExpression()
    */

   //WRONG LOGIC. DO IT
   public R visit(CompareExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);

      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder compareExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               compareExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               compareExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            compareExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            compareExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerRHS.get(assignmentLHSVarName) + ");\n");
         } else {
            compareExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(compareExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "!="
    * f2 -> SubPrimaryExpression()
    */
   public R visit(NeqExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder neqExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               neqExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               neqExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            neqExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            neqExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerRHS.get(assignmentLHSVarName) + ");\n");
         } else {
            neqExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(neqExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "+"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(PlusExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String)n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);

      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder plusExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               plusExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               plusExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }
         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            plusExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            plusExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerRHS.get(assignmentLHSVarName) + ");\n");
         } else {
            plusExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(plusExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "-"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(MinusExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }

      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder minusExpression = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               minusExpression.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               minusExpression.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            minusExpression.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            minusExpression.append("store(mthis, " + fieldIndex + ", " + varLinkerLHS.get(assignmentLHSVarName) + ");\n");
         } else {
            minusExpression.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(minusExpression);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "*"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(TimesExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }

      } else {
         /**
          * cases to handle->
          * 1. if constant, print as it is
          * 2. if int type variable, then do the varLinker mapping
          * 3. if class field, then load it and then do varLinker mapping
          */
         StringBuilder multiplicationExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               multiplicationExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               multiplicationExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            multiplicationExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            multiplicationExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerLHS.get(assignmentLHSVarName) + ");\n");
         } else {
            multiplicationExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(multiplicationExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "/"
    * f2 -> SubPrimaryExpression()
    */
   public R visit(DivExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String expr1 = (String) n.f0.accept(this);
      String expr1Type = symbolTable.getType(currentClass, currentMethod, expr1);
      n.f1.accept(this);
      String expr2 = (String)n.f2.accept(this);
      String expr2Type = symbolTable.getType(currentClass, currentMethod, expr2);
      if(firstPass){
         /**
          * cases to check:
          * 1. is it some type of constant
          * 2. is it local variable
          * 3. is it a class field --> yes ---> to which class does it belong?
          */
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr1)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr1);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr1, declarationClassOfField);
            }
         }

         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(expr2)){
               String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, expr2);
               secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(expr2, declarationClassOfField);
            }
         }

         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfField = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfField);
         }
      } else {
         StringBuilder divExpressionSB = new StringBuilder();
         if(!helper.isStringInt(expr1) && expr1Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr1)){
               divExpressionSB.append(varLinkerRHS.get(expr1) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr1)).fieldInfo.get(expr1).fieldIndex + ");\n");
            }
         }
         if(!helper.isStringInt(expr2) && expr2Type == "int"){
            if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.containsKey(expr2)){
               divExpressionSB.append(varLinkerRHS.get(expr2) + " = (Integer) load(mthis, " + object.ObjectTable.get(symbolTable.getDeclarationClassOfField(currentClass, expr2)).fieldInfo.get(expr2).fieldIndex + ");\n");
            }
         }

         if(secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.containsKey(assignmentLHSVarName)){
            divExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
            String declarationClassOfField = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
            int fieldIndex = object.ObjectTable.get(declarationClassOfField).fieldInfo.get(assignmentLHSVarName).fieldIndex;
            divExpressionSB.append("store(mthis, " + fieldIndex + ", " + varLinkerLHS.get(assignmentLHSVarName) + ");\n");
         } else {
            divExpressionSB.append(assignmentLHSVarName).append(" = ").append(helper.isStringInt(expr1) ? expr1 : (varLinkerRHS.get(expr1) == null ? expr1 : varLinkerRHS.get(expr1))).append(" ").append(n.f1.tokenImage).append(" ").append((helper.isStringInt(expr2) ? expr2 : (varLinkerRHS.get(expr2) == null ? expr2 : varLinkerRHS.get(expr2))) + ";\n");
         }
         _ret = uncheckedCast(divExpressionSB);
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    */
   public R visit(FieldReference n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String classObjectName = (String)n.f0.accept(this);
      String classObjectType = symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.get(classObjectName);
      n.f1.accept(this);
      String fieldName = (String)n.f2.accept(this);
      if(firstPass){
         secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(fieldName, classObjectType);
         if(!symbolTable.table.get(currentClass).classMethods.get(currentMethod).methodVars.containsKey(assignmentLHSVarName)){
            String declarationClassOfLHS = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
            secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfLHS);
         }
      } else {
         StringBuilder fieldReferenceSB = new StringBuilder();
         int fieldIndex = object.ObjectTable.get(classObjectType).fieldInfo.get(fieldName).fieldIndex;
         if(currentMethod == "main"){
            fieldReferenceSB.append(assignmentLHSVarName + " = " + "(Integer) load(" + classObjectName + ", " + fieldIndex + ");\n");
         } else {
            fieldReferenceSB.append(varLinkerRHS.get(fieldName) + " = " + "(Integer) load(mthis, " + fieldIndex + ");\n");
         }
         /**
          * if LHS of assignment is a class field --> store it.
          */
         if(currentMethod == "main"){
            if(symbolTable.table.get(currentClass).classFields.containsKey(varLinkerLHS.get(assignmentLHSVarName))){
               String LHSFieldDeclarationClass = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
               int LHSFieldIndex = object.ObjectTable.get(LHSFieldDeclarationClass).fieldInfo.get(assignmentLHSVarName).fieldIndex;
               fieldReferenceSB.append("store(" + classObjectName + ", " + LHSFieldIndex + ", " + varLinkerLHS.get(fieldName) + ");\n");
            } else {
               //fieldReferenceSB.append(assignmentLHSVarName + " = " + varLinkerRHS.get(fieldName) + ";\n");
            }
         } else {
            if(symbolTable.table.get(currentClass).classFields.containsKey(varLinkerLHS.get(assignmentLHSVarName))){
               String LHSFieldDeclarationClass = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.get(assignmentLHSVarName);
               int LHSFieldIndex = object.ObjectTable.get(LHSFieldDeclarationClass).fieldInfo.get(assignmentLHSVarName).fieldIndex;
               fieldReferenceSB.append("store(mthis, " + LHSFieldIndex + ", " + varLinkerLHS.get(fieldName) + ");\n");
            } else {
               fieldReferenceSB.append(assignmentLHSVarName + " = " + varLinkerRHS.get(fieldName) + ";\n");
            }
         }
         _ret = (R)fieldReferenceSB;
      }

      return (_ret == null ? (R)new StringBuilder() : _ret);
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n) {
      R _ret = null;
      assignmentVariableShitON = false;
      String varName = (String)n.f0.accept(this);
      String varType = symbolTable.getType(currentClass, currentMethod, varName);
      String methodName = (String)n.f2.accept(this);

      if(firstPass){
         n.f1.accept(this);
         n.f3.accept(this);
         n.f4.accept(this);
         n.f5.accept(this);
      } else {
         StringBuilder messageSendSB = new StringBuilder();
         if(currentMethod == "main"){
            messageSendSB.append("vTablePtr = load(").append(varName).append(", 0);\n");
            /**
             * CHANGES DONE HERE
             */
            int methodIndexInvTable = object.ObjectTable.get(symbolTable.getDeclarationClassOfMethod(varType, methodName)).vTable.get(methodName).methodIndex;
            messageSendSB.append("fnName = (String) load(vTablePtr, ").append(methodIndexInvTable).append(");\n");
            messageSendSB.append(assignmentLHSVarName).append(" = (Integer) callFunc(fnName, " + varName);
            messageSendSB.append(((R)n.f4.accept(this) == null ? "" : (R)n.f4.accept(this)));
            messageSendSB.append(");\n");
         } else {
            messageSendSB.append("vTablePtr = load(mthis, 0);\n");
            String declarationClassOfMethod = symbolTable.getDeclarationClassOfMethod(varType, methodName);
            int methodIndexInvTable = object.ObjectTable.get(declarationClassOfMethod).vTable.get(methodName).methodIndex;
            messageSendSB.append("fnName = (String) load(vTablePtr, ").append(methodIndexInvTable).append(");\n");
            messageSendSB.append(assignmentLHSVarName).append(" = (Integer) callFunc(fnName, mthis");
            messageSendSB.append(((R)n.f4.accept(this) == null ? "" : (R)n.f4.accept(this)));
            messageSendSB.append(");\n");
         }
         _ret = uncheckedCast(messageSendSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> ( ArgRest() )*
    */
   public R visit(ArgList n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
      } else{
         StringBuilder argListSB = new StringBuilder();
         argListSB.append((n.f0.accept(this) == null ? n.f0.accept(this) : ", " + n.f0.accept(this)));
         for(Node argRest : n.f1.nodes){
            argListSB.append(argRest.accept(this));
         }
         _ret = uncheckedCast(argListSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> ","
    * f1 -> SubPrimaryExpression()
    */
   public R visit(ArgRest n) {
      R _ret=null;
      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
      } else {
         StringBuilder argRestSB = new StringBuilder();
         argRestSB.append((n.f1.accept(this) == null ? "" : ", " + n.f1.accept(this)));
         _ret = uncheckedCast(argRestSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    */
   public R visit(PrimaryExpression n) {
      R _ret=null;
      if(firstPass){
         _ret = n.f0.accept(this);
      } else{
         _ret = n.f0.accept(this);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | False
    *       | Literal()
    *       | Identifier()
    */
   public R visit(SubPrimaryExpression n) {
      R _ret= null;
      if(firstPass){
         _ret = n.f0.accept(this);
      } else{
         _ret = n.f0.accept(this);
      }
      return (_ret == null ? (R)"" : _ret);
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret = null;
      if(firstPass){
         _ret = (R)n.f0.tokenImage;
      } else {
         if(assignmentVariableShitON){
            StringBuilder integerLiteralSB = new StringBuilder();
            if(symbolTable.table.get(currentClass).classFields.containsKey(assignmentLHSVarName)){
               String declarationClassOfLHS = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
               int fieldIndex = object.ObjectTable.get(declarationClassOfLHS).fieldInfo.get(assignmentLHSVarName).fieldIndex;
               if(currentMethod == "main"){
                  integerLiteralSB.append("store(" + declarationClassOfLHS + ", " + fieldIndex + ", " + (R)n.f0.tokenImage + ");\n");
               } else {
                  integerLiteralSB.append("store(mthis, " + fieldIndex + ", " + (R)n.f0.tokenImage + ");\n");
               }
            } else {
               integerLiteralSB.append((assignmentLHSVarName + " = " + (R)n.f0.tokenImage + ";\n"));
            }
            _ret = (R)integerLiteralSB;
         } else {
            _ret = (R)n.f0.tokenImage;
         }
      }
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n) {R _ret = null;
      if(firstPass){
         _ret = (R)n.f0.tokenImage;
      } else {
         if(assignmentVariableShitON){
            StringBuilder trueLiteralSB = new StringBuilder();
            trueLiteralSB.append((assignmentLHSVarName + " = " + (R)n.f0.tokenImage + ";\n"));
            _ret = (R)trueLiteralSB;
         } else {
            _ret = (R)n.f0.tokenImage;
         }
      }
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n) {
      R _ret = null;
      if(firstPass){
         _ret = (R)n.f0.tokenImage;
      } else {
         if(assignmentVariableShitON){
            StringBuilder falseLiteralSB = new StringBuilder();
            falseLiteralSB.append((assignmentLHSVarName + " = " + (R)n.f0.tokenImage + ";\n"));
            _ret = (R)falseLiteralSB;
         } else {
            _ret = (R)n.f0.tokenImage;
         }
      }
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n) {
      R _ret = null;
      String identifier = (String) n.f0.tokenImage;

      if(firstPass){
         if(currentMethod != "main"){
            if(assignmentVariableShitON){
               String identifierType = symbolTable.getType(currentClass, currentMethod, identifier);
               if(!helper.isStringInt(identifier) && identifierType == "int"){
                  String declarationClassOfIdentifier = symbolTable.getDeclarationClassOfField(currentClass, identifier);
                  if(declarationClassOfIdentifier != null){
                     secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInRHSThisMethod.put(identifier, declarationClassOfIdentifier);
                  }
               }

               String declarationClassOfAssignmentVar = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
               if (declarationClassOfAssignmentVar != null){
                  secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).fieldsUsedInLHSThisMethod.put(assignmentLHSVarName, declarationClassOfAssignmentVar);
               }
            }
         }
         _ret = (R)n.f0.tokenImage;
      } else {
         /**
          * cases to handle:
          * 1.LHS is class field, then do the store part
          */
         if(assignmentVariableShitON){
            StringBuilder identiferLiteralSB = new StringBuilder();
            if(symbolTable.table.get(currentClass).classFields.containsKey(identifier)){
               String declarationClassOfIdentifier = symbolTable.getDeclarationClassOfField(currentClass, identifier);
               int fieldIndexIdentifier = object.ObjectTable.get(declarationClassOfIdentifier).fieldInfo.get(identifier).fieldIndex;
               if(currentMethod != "main"){
                  identiferLiteralSB.append(varLinkerRHS.get(identifier) + " = (Integer) load(mthis, " + fieldIndexIdentifier + ");\n");
               }
            }

            if(symbolTable.table.get(currentClass).classFields.containsKey(assignmentLHSVarName)){
               String declarationClassOfLHS = symbolTable.getDeclarationClassOfField(currentClass, assignmentLHSVarName);
               int fieldIndexAssignmentVar = object.ObjectTable.get(declarationClassOfLHS).fieldInfo.get(assignmentLHSVarName).fieldIndex;
               if(currentMethod == "main"){
                  identiferLiteralSB.append("store(" + declarationClassOfLHS + ", " + fieldIndexAssignmentVar + ", " + (R)n.f0.tokenImage + ");\n");
               } else {
                  if(symbolTable.table.get(currentClass).classFields.containsKey(identifier)){
                     identiferLiteralSB.append("store(mthis, " + fieldIndexAssignmentVar + ", " + varLinkerRHS.get(identifier) + ");\n");
                  } else {
                     identiferLiteralSB.append("store(mthis, " + fieldIndexAssignmentVar + ", " + identifier + ");\n");
                  }
               }
            } else {
               identiferLiteralSB.append((assignmentLHSVarName + " = " + identifier + ";\n"));
            }
            _ret = (R)identiferLiteralSB;
         } else {
            _ret = (R)identifier;
         }
      }
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n) {
      return (R)new StringBuilder();
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n) {
      R _ret = null;
      assignmentVariableShitON = false;
      n.f0.accept(this);
      String className = (String)n.f1.accept(this);

      if(firstPass){
         /**
          * object created for LHSObjectAllocation for methodVariable
          */
         secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(assignmentLHSVarName).isObjectCreated = true;
      } else {
         /**
          * alloc fields
          */
         StringBuilder allocationExpressionSB = new StringBuilder();
         String objectNameForVarAllocation = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(LHSObjectAllocation).linkedVariables.get(0);
         allocationExpressionSB.append(objectNameForVarAllocation).append(" = alloc(").append(symbolTable.getTotalSizeofClassFields(className) + 4).append(");\n");

         int classFieldMapping = 4;
         Stack<String> allInheritedClassesIncludingThis = secPassSymTbl.getAllParents(className);
         while(!allInheritedClassesIncludingThis.isEmpty()){
            String poppedClass = allInheritedClassesIncludingThis.pop();
            object.ObjectTable.put(poppedClass, new ObjectTable(poppedClass));
            for(Map.Entry<String, SecPassClassFieldInfo> allFields : secPassSymTbl.table.get(poppedClass).classMapping.entrySet()){
               object.ObjectTable.get(poppedClass).fieldInfo.put(allFields.getKey(), new FieldInfo(allFields.getKey(), LHSObjectAllocation, classFieldMapping));
               allocationExpressionSB.append("store(").append(objectNameForVarAllocation).append(", ").append(classFieldMapping).append(", 0);\n");
               classFieldMapping += 4;
            }
         }

         /**
          * alloc methods
          */
         int classMethodMapping = 0;
         String objectNameForMethodAllocation = secPassSymTbl.table.get(currentClass).methodMapping.get(currentMethod).variableMappings.get(LHSObjectAllocation).linkedVariables.get(1);
         allInheritedClassesIncludingThis = secPassSymTbl.getAllParents(className);
         LinkedHashMap<String, String> vTable = symbolTable.getAllocMethodTableWithOverriding(allInheritedClassesIncludingThis);
         allocationExpressionSB.append(objectNameForMethodAllocation).append(" = alloc(").append(vTable.size() * 4).append(");\n");
         for(Map.Entry<String, String> methodOverriding : vTable.entrySet()){
            String[] split_value = methodOverriding.getValue().split("_", 2);
            object.ObjectTable.get(split_value[0]).vTable.put(split_value[1], new vTable(split_value[1], methodOverriding.getValue(), classMethodMapping));
            allocationExpressionSB.append("store(").append(objectNameForMethodAllocation).append(", ").append(classMethodMapping).append(", \"").append(methodOverriding.getValue()).append("\");\n");
            classMethodMapping += 4;
         }
         allocationExpressionSB.append("store(").append(objectNameForVarAllocation).append(", ").append(0).append(", ").append(objectNameForMethodAllocation).append(");\n");
         allocationExpressionSB.append(assignmentLHSVarName).append(" = ").append(objectNameForVarAllocation).append(";\n");
         _ret = uncheckedCast(allocationExpressionSB);
      }
      LHSObjectAllocation = "";
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public R visit(NotExpression n) {
      R _ret=null;
      assignmentVariableShitON = false;
      String RHS = (String)n.f1.accept(this);

      if(firstPass){
         n.f0.accept(this);
         n.f1.accept(this);
      } else {
         StringBuilder notExpressionSB = new StringBuilder();
         notExpressionSB.append(assignmentLHSVarName + " = ").append("!").append(varLinkerRHS.get(RHS) + ";\n");
         _ret = uncheckedCast(notExpressionSB);
      }
      return (_ret == null ? uncheckedCast(new StringBuilder()) : _ret);
   }
}
